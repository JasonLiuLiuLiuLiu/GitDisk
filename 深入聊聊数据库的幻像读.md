# 前言  

每次谈到数据库的事务隔离级别,大家一定会看到这张表.  

![事务隔离级别](https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/resource/PhantomRead/事务隔离级别.png)  

其中,`可重复读`这个隔离级别,有效地防止了脏读和不可重复读,但任然可能发生幻读,**可能**发生幻读就表示`可重复读`这个隔离级别防不住幻读吗?

我不管从数据库方面的教科书还是一些网络教程上,经常看到RR级别是可以重复读的,但是无法解决幻读,只有可串行化(Serializable)才能解决幻读,这个说法是否正确呢?  

在这篇文章中,我将重点围绕MySQL中  
**可重复读（Repeatable read）能防住幻读吗?**  
这一问题展开讨论,相信看完这篇文章后,你一定会对事务隔离级别有新的认识.  

我们的数据库中有如下结构和数据的`Users`表,下文中我们将对这张表进行操作,

![users](https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/resource/PhantomRead/users.png)  

长文预警,读完此篇文章,大概需要您二十至三十分钟(我写了一星期😭).

# 什么是幻读?  

在说幻读之前,我们要先来了解脏读和不可重复读.

## 脏读  

当一个事务读取到另外一个事务修改但未提交的数据时，就可能发生脏读。  

![脏读](https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/resource/PhantomRead/脏读.png) 

在我们的例子中，事务2修改了一行，但是没有提交，事务1读了这个没有提交的数据。现在如果事务2回滚了刚才的修改或者做了另外的修改的话，事务1中查到的数据就是不正确的了,所以这条数据就是脏读。

## 不可重复读  

“不可重复读”现象发生在当执行SELECT 操作时没有获得读锁或者SELECT操作执行完后马上释放了读锁； 另外一个事务对数据进行了更新,读到了不同的结果.

![不可重复读](https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/resource/PhantomRead/不可重复读.png) 

在这个例子中，事务2提交成功，因此他对id为1的行的修改就对其他事务可见了。但是事务1在此前已经从这行读到了另外一个“age”的值,数据库在第二次SELECT请求的时候应该返回事务2更新之前的值。

## 幻读  

“幻读”又叫"幻象读",是''不可重复读''的一种特殊场景：当事务1两次执行''SELECT ... WHERE''检索一定范围内数据的操作中间，事务2在这个表中创建了(如[[INSERT]])了一行新数据，这条新数据正好满足事务1的“WHERE”子句。

![幻读](https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/resource/PhantomRead/幻读.png) 

需要指出的是事务1执行了两遍同样的查询语句,第二遍比第一遍多出了一条数据,这就是幻读。

## 三者到底什么区别  

三者的场景介绍完,但是一定任然有很多同学搞不清楚,它们到底有什么区别,我总结一下.

脏读:指读到了其他事务未提交的数据.  
不可重复读: 读到了其他事务已提交的数据(update).  

不可重复读与幻读都是读到其他事务已提交的数据,但是它们针对点不同.  
不可重复读:update.  
幻读:delete,insert.  


# MySQL中的四种事务隔离级别

## 未提交读

未提交读（READ UNCOMMITTED）是最低的隔离级别,在这种隔离级别下,如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据.   

把脏读的图拿来分析分析,因为事务2更新id=1的数据后,任然允许事务1读取该条数据,所以事务1第二次执行查询,读到了事务2更新的结果,产生了脏读.     

![脏读](https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/resource/PhantomRead/脏读.png) 

## 已提交读

由于MySQL的InnoDB默认是使用的RR级别，所以我们先要将该session开启成RC级别，并且设置binlog的模式

``` sql
SET session transaction isolation level read committed;
SET SESSION binlog_format = 'ROW';（或者是MIXED）
```

在已提交读（READ COMMITTED）级别中，读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行,会对该写锁一直保持直到到事务提交.  

同样,我们来分析脏读,事务2更新id=1的数据后,在提交前,会对该对象写锁,所以事务1读取id=1的数据时,会一直等待事务2结束,处于阻塞状态,避免了产生脏读.    

![脏读](https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/resource/PhantomRead/脏读.png) 

同样,来分析不可重复读,事务1读取id=1的数据后并没有锁住该数据,所以事务2能对这条数据进行更新,事务2对更新提交后,该数据即生效,所以事务1再次执行同样的查询,查询到的结果便与第一次查到的不同,所以已提交读防不了不可重复读.  
![不可重复读](https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/resource/PhantomRead/不可重复读.png) 


## 可重复度

在可重复读（REPEATABLE READS）是介于已提交读和可串行化之间的一种隔离级别(废话😅),InnoDb的默认隔离级别,它是我这篇文章的重点讨论对象,所以在这里我先卖个关子,后面我会详细介绍.

## 可串行化  

可串行化（Serializable ）是高的隔离级别,它求在选定对象上的读锁和写锁保持直到事务结束后才能释放,所以能防住上诉所有问题,但因为是串行化的,所以效率较低.  

<img src="https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/resource/PhantomRead/说正事.jpg" alt="说正事" width="400"/>  

了解到了上诉的一些背景知识后,下面正式开始我们的议题.  

**可重复读（Repeatable read）能防住幻读吗?**  

# 可重复读

在讲可重复读之前,我们先在mysql的InnoDB下做下面的实验.  

![幻读](https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/resource/PhantomRead/RR.png) 
可以看到,事务A既没有读到事务B更新的数据,也没有读到事务C添加的数据,所以在这个场景下,它既防住了不可重复读,也防住了幻读.  

到此为止,相信大家已经知道答案了,这是怎么做到的呢?  

## 悲观锁与乐观锁

我们前面说的在对象上加锁,这种锁是`排它锁`,这种处理方案是悲观锁机制,有很多文章说`可重复读`的隔离级别防不了幻读, 是认为可重复读会对读的行加锁,其他事务修改不了这条数据,直到事务结束,这种方案只能锁住数据行,但是有新的数据进来,是阻止不了的,所以会产生幻读.  

可是MySQL、ORACLE、PostgreSQL等已经是非常成熟的数据库了,怎么会单纯地采用这种如此影响性能的方案呢?

![mysql](https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/resource/PhantomRead/mysql.png)

### 悲观锁

正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。

### 乐观锁

相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。

而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。

MySQL、ORACLE、PostgreSQL等都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免不可重复读和幻读,MVCC的实现没有固定的规范，每个数据库都会有不同的实现方式，这里讨论的是InnoDB的MVCC。

## MVCC(多版本并发控制)

在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 在可重读Repeatable reads事务隔离级别下：

* SELECT时，读取创建版本号<=当前事务版本号，删除版本号为空或>当前事务版本号。
* INSERT时，保存当前事务版本号为行的创建版本号
* DELETE时，保存当前事务版本号为行的删除版本号
* UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行

![mvcc](https://raw.githubusercontent.com/liuzhenyulive/GitDisk/blogs/resource/PhantomRead/mvcc.png)

通过MVCC,虽然每行记录都要额外的存储空间来记录version,更多的行检查工作以及一些额外的维护工作,但可以减少锁的使用,大多读操作都不用加锁,读取数据操作简单,性能好.  

但是细心的同学应该也看到了,通过MVCC读取出来的数据其实是历史数据,而不是最新数据,这在一些对于数据时效特别敏感的业务中,很可能出问题,这也是MVCC的短板之处,有办法解决吗? 当然有.

MCVV这种读取历史数据的方式称为快照读(snapshot read),而读取数据库当前版本数据的方式,叫当前读(current read).  

### 快照读  

我们平时只用使用select就是快照读,这样可以减少加锁所带来的开销.  

``` sql
select * from table ....
```

### 当前读  

对于会对数据修改的操作(update、insert、delete)都是采用当前读的模式。在执行这几个操作时会读取最新的记录，即使是别的事务提交的数据也可以查询到。假设要update一条记录，但是在另一个事务中已经delete掉这条数据并且commit了，如果update就会产生冲突，所以在update的时候需要知道最新的数据。读取的是最新的数据，需要加锁。以下第一个语句需要加共享锁，其它都需要加排它锁。

``` sql
select * from table where ? lock in share mode; 
select * from table where ? for update; 
insert; 
update; 
delete;
```

那么,我们利用当前读来做试验.

首先,在读提交的隔离级别下.  

然后在可重复读的隔离级别下.

## Next-Key锁
