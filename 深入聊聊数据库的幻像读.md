# 前言  

每次谈到数据库的事务隔离级别,大家一定会看到这张表.  

|         **隔离级别**         | **脏读（Dirty Read）** | **不可重复读（NonRepeatable Read）** | **幻读（Phantom Read）** |
| :--------------------------: | :--------------------: | :----------------------------------: | :----------------------: |
| 未提交读（Read uncommitted） |          可能          |                 可能                 |           可能           |
|  已提交读（Read committed）  |         不可能         |                 可能                 |           可能           |
| 可重复读（Repeatable read）  |         不可能         |                不可能                |           可能           |
|  可串行化（Serializable ）   |         不可能         |                不可能                |          不可能          |

其中,`可重复读`这个隔离级别,有效地防止了脏读和不可重复读,但任然可能发生幻读,`可能`发生幻读就表示`可重复读`这个隔离级别防不住幻读吗?

在这篇文章中,我将重点围绕MySQL中  
**可重复读（Repeatable read）能防住幻读吗?**  
这一问题展开讨论,相信看完这篇文章后,你一定会对事务隔离级别有新的认识.  

我们的数据库中有如下结构和数据的`Users`表,下文中我们将对这张表进行操作.

|  id   | name  |  age  |
| :---: | :---: | :---: |
|   1   |  Joe  |  20   |
|   2   | Jill  |  25   |


# 什么是幻读?  

在说幻读之前,我们要先来了解脏读和不可重复读.

## 脏读  

当一个事务读取到另外一个事务修改但未提交的数据时，就可能发生脏读。  



在我们的例子中，事务2修改了一行，但是没有提交，事务1读了这个没有提交的数据。现在如果事务2回滚了刚才的修改或者做了另外的修改的话，事务1中查到的数据就是不正确的了,所以这条数据就是脏读。

## 不可重复读  

“不可重复读”现象发生在当执行SELECT 操作时没有获得读锁或者SELECT操作执行完后马上释放了读锁； 另外一个事务对数据进行了更新,读到了不同的结果.



在这个例子中，事务2提交成功，因此他对id为1的行的修改就对其他事务可见了。但是事务1在此前已经从这行读到了另外一个“age”的值,数据库在第二次SELECT请求的时候应该返回事务2更新之前的值。

## 幻读  

“幻读”是''不可重复读''的一种特殊场景：当事务1两次执行''SELECT ... WHERE''检索一定范围内数据的操作中间，事务2在这个表中创建了(如[[INSERT]])了一行新数据，这条新数据正好满足事务1的“WHERE”子句。



需要指出的是事务1执行了两遍同样的查询语句,第二遍比第一遍多出了一条数据,这就是幻读。

## 三者到底什么区别  

三者的场景介绍完,但是一定任然有很多同学搞不清楚,它们到底有什么区别,我用下表总结一下.

脏读:指读到了其他事务未提交的数据.  
不可重复读: 读到了其他事务已提交的数据(update).  

不可重复读与幻读都是读到其他事务已提交的数据,但是它们针对点不同.  
不可重复读:update.  
幻读:delete,insert.  


# MySQL中的四种事务隔离级别

## 未提交读

未提交读（READ UNCOMMITTED）是最低的隔离级别,在这种隔离级别下,如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，但允许其他事务读此行数据.   

把脏读的图拿来分析分析.  



## 已提交读

在已提交读（READ COMMITTED）级别中，读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行,会对该写锁一直保持直到到事务提交.  

把脏读的图拿来分析.

把不可重复读的图拿来分析.  


## 可重复度

在可重复读（REPEATABLE READS）是介于已提交读和可串行化之间的一种隔离级别(废话😅),这个隔离级别正是我这篇文章的重点讨论对象,所以在这里我先卖个关子,后面我会详细介绍.

## 可串行化  

可串行化（Serializable ）是高的隔离级别,它求在选定对象上的读锁和写锁保持直到事务结束后才能释放,所以能防住上诉所有问题,但因为是串行化的,所以效率较低.

# 可重复读



## 悲观锁与乐观锁

### 悲观锁

### 乐观锁

## MVCC(多版本并发控制)

### 快照读

### 当前读

### Next-Key锁
