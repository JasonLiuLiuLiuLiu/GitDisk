# 前言  

每次谈到数据库的事务隔离级别,大家一定会看到这张表.  

|         **隔离级别**         | **脏读（Dirty Read）** | **不可重复读（NonRepeatable Read）** | **幻读（Phantom Read）** |
| :--------------------------: | :--------------------: | :----------------------------------: | :----------------------: |
| 未提交读（Read uncommitted） |          可能          |                 可能                 |           可能           |
|  已提交读（Read committed）  |         不可能         |                 可能                 |           可能           |
| 可重复读（Repeatable read）  |         不可能         |                不可能                |           可能           |
|  可串行化（Serializable ）   |         不可能         |                不可能                |          不可能          |

其中,`可重复读`这个隔离级别,有效地防止了脏读和不可重复读,但任然可能发生幻读,`可能`发生幻读就表示`可重复读`这个隔离级别防不了幻读吗?

在这篇文章中,我将围绕MySQL中  
**可重复读（Repeatable read）能防住幻读吗?**  
这一问题展开讨论,相信看完这篇文章后,你一定会对事务隔离级别有新的认识.  

我们的数据库中有如下结构和数据的`Users`表,下文中我们将对这张表进行操作.

|  id   | name  |  age  |
| :---: | :---: | :---: |
|   1   |  Joe  |  20   |
|   2   | Jill  |  25   |


# 什么是幻读?  

在说幻读之前,我们要先来了解脏读和不可重复读.

## 脏读  
当一个事务允许读取另外一个事务修改但未提交的数据时，就可能发生脏读。

脏读和不可重复读（non-repeatable reads）类似。事务2没有提交造成事务1的语句1两次执行得到不同的结果集。在未提交读隔离级别唯一禁止的是更新混乱，即早期的更新可能出现在后来更新之前的结果集中。

在我们的例子中，事务2修改了一行，但是没有提交，事务1读了这个没有提交的数据。现在如果事务2回滚了刚才的修改或者做了另外的修改的话，事务1中查到的数据就是不正确的了。  

|             **事务 1**              |               **事务 2**                |
| :---------------------------------: | :-------------------------------------: |
|            /* Query 1 */            |                                         |
| SELECT age FROM users WHERE id = 1; |                                         |
|         /* will read 20 */          |                                         |
|                                     |              /* Query 2 */              |
|                                     | UPDATE users SET age = 21 WHERE id = 1; |
|                                     |          /* No commit here */           |
|            /* Query 1 */            |                                         |
| SELECT age FROM users WHERE id = 1; |                                         |
|         /* will read 21 */          |                                         |
|                                     |  ROLLBACK; /* lock-based DIRTY READ */  |

在这个例子中，事务2回滚后就没有id是1，age是21的数据行了。

## 不可重复读  

在一次事务中，当一行数据获取两遍得到不同的结果表示发生了“不可重复读”.

在基于锁的并发控制中“不可重复读”现象发生在当执行SELECT 操作时没有获得读锁或者SELECT操作执行完后马上释放了读锁； 多版本并发控制中当没有要求一个提交冲突(commit conflict)的事务回滚也会发生“不可重复读”现象。

|                **事务 1**                |                **事务 2**                |
| :--------------------------------------: | :--------------------------------------: |
|              /* Query 1 */               |                                          |
|   SELECT age FROM users WHERE id = 1;    |                                          |
|                                          |              /* Query 2 */               |
|                                          | UPDATE users SET age = 21 WHERE id = 1;  |
|                                          |  COMMIT; /* in multiversion concurrency  |
|                                          | control, or lock-based READ COMMITTED */ |
|              /* Query 1 */               |                                          |
|   SELECT age FROM users WHERE id = 1;    |                                          |
| COMMIT; /* lock-based REPEATABLE READ */ |                                          |

在这个例子中，事务2提交成功，因此他对id为1的行的修改就对其他事务可见了。但是事务1在此前已经从这行读到了另外一个“age”的值。在可序列化（SERIALIZABLE）和可重复读的隔离级别，数据库在第二次SELECT请求的时候应该返回事务2更新之前的值。在提交读和未提交读，返回的是更新之后的值，这个现象就是不可重复读。

有两种策略可以避免不可重复读。一个是要求事务2延迟到事务1提交或者回滚之后再执行。这种方式实现了T1, T2 的串行化调度。串行化调度可以支持可重复读。

另一种策略是多版本并发控制。为了得到更好的并发性能，允许事务2先提交。但因为事务1在事务2之前开始，事务1必须在其开始执行时间点的数据库的快照上面操作。当事务1最终提交时候，数据库会检查其结果是否等价于T1, T2串行调度。如果等价，则允许事务1提交，如果不等价，事务1需要回滚并抛出个串行化失败的错误。

使用基于锁的并发控制，在可重复读的隔离级别中，ID=1的行会被锁住，在事务1提交或回滚前一直阻塞语句2的执行。在提交读的级别，语句1第二次执行，age已经被修改了。

在多版本并发控制机制下，可序列化(SERIALIZABLE)级别，两次SELECT语句读到的数据都是事务1开始的快照，因此返回同样的数据。但是，如果事务1试图UPDATE这行数据，事务1会被要求回滚并抛出一个串行化失败的错误。

在提交读隔离级别，每个语句读到的是语句执行前的快照，因此读到更新前后不同的值。在这种级别不会有串行化的错误（因为这种级别不要求串行化），事务1也不要求重试。

## 幻读  

在事务执行过程中，当两个完全相同的查询语句执行得到不同的结果集。这种现象称为“幻读（phantom read）”

“幻读”是''不可重复读''的一种特殊场景：当事务1两次执行''SELECT ... WHERE''检索一定范围内数据的操作中间，事务2在这个表中创建了(如[[INSERT]])了一行新数据，这条新数据正好满足事务1的“WHERE”子句。

|          **事务 1**          |                 **事务 2**                 |
| :--------------------------: | :----------------------------------------: |
|        /* Query 1 */         |                                            |
|     SELECT * FROM users      |                                            |
| WHERE age BETWEEN 10 AND 30; |                                            |
|                              |               /* Query 2 */                |
|                              | INSERT INTO users VALUES ( 3, 'Bob', 27 ); |
|                              |                  COMMIT;                   |
|        /* Query 1 */         |                                            |
|     SELECT * FROM users      |                                            |
| WHERE age BETWEEN 10 AND 30; |                                            |

需要指出的是事务1执行了两遍同样的查询语句。如果设了最高的隔离级别，两次会得到同样的结果集，这也正是数据库在可序列化（SERIALIZABLE）隔离级别上需要满足的。但是在较低的隔离级别上，第二次查询可能会得到不同的结果集。

在可序列化隔离级别，查询语句1在age从10到30的记录上加锁，事务2只能阻塞直至事务1提交。


## 不可重复读与幻读有什么区别  

很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。

如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。

所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。

上文说的，是使用悲观锁机制来处理这两种问题，但是MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。

# MySQL中的四种事务隔离级别

## 未提交读

未提交读（READ UNCOMMITTED）是最低的隔离级别,在这种隔离级别下,读不加锁,写不加锁,允许“脏读”（dirty reads），事务可以看到其他事务“尚未提交”的修改.

## 已提交读

在已提交读（READ COMMITTED）级别中，需要对选定对象的写锁一直保持直到到事务结束，但是读锁在SELECT操作完成后马上释放,因此“不可重复读”现象可能会发生,能防止脏读。

## 可重复度

在可重复读（REPEATABLE READS）隔离级别中，需要对选定对象的读锁（read locks）和写锁（write locks）一直保持到事务结束，但不要求“范围锁”，因此可能会发生“幻影读”。

## 可串行化  

最高的隔离级别。

在基于锁机制并发控制的DBMS实现可串行化，要求在选定对象上的读锁和写锁保持直到事务结束后才能释放。在SELECT 的查询中使用一个“WHERE”子句来描述一个范围时应该获得一个“范围锁”（range-locks）。这种机制可以避免“幻读”（phantom reads）现象（详见下文）。

当采用不基于锁的并发控制时不用获取锁。但当系统探测到几个并发事务有“写冲突”的时候，只有其中一个是允许提交的。这种机制的详细描述见“快照隔离”

# 悲观锁与乐观锁

## 悲观锁

## 乐观锁

# MVCC(多版本并发控制)

## 快照读

## 当前读

## Next-Key锁
