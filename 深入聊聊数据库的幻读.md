# 前言  

每次谈到数据库的事务隔离级别,大家一定会看到这张表.  

**隔离级别**|**脏读（Dirty Read）**|**不可重复读（NonRepeatable Read）**|**幻读（Phantom Read）**
:-----:|:-----:|:-----:|:-----:
未提交读（Read uncommitted）|可能|可能|可能
已提交读（Read committed）|不可能|可能|可能
可重复读（Repeatable read）|不可能|不可能|可能
可串行化（Serializable ）|不可能|不可能|不可能

其中,`可重复读`这个隔离级别,有效地防止了脏读和不可重复读,但任然有可能发生幻读,可能发生幻读就表示这个隔离级别防不了幻读吗?

在这篇文章中,我将围绕MySQL中  
**可重复读（Repeatable read）能防住幻读吗?**  
这一问题展开讨论,相信看完这篇文章后,你一定会对事务隔离级别有新的认识.  

# 什么是幻读?

===幻影读===

在事务执行过程中，当两个完全相同的查询语句执行得到不同的结果集。这种现象称为“幻影读（phantom read）”

当事务没有获取''{{tsl|en|range locks|范围锁}}''的情况下执行''[[Select (SQL)|SELECT]] ... WHERE''操作可能会发生“幻影读”。

“幻影读”是''不可重复读''的一种特殊场景：当事务1两次执行''SELECT ... WHERE''检索一定范围内数据的操作中间，事务2在这个表中创建了(如[[INSERT]])了一行新数据，这条新数据正好满足事务1的“WHERE”子句。

**事务 1**|**事务 2**
:-----:|:-----:
/* Query 1 */| 
SELECT * FROM users| 
WHERE age BETWEEN 10 AND 30;| 
 | 
 |/* Query 2 */
 |INSERT INTO users VALUES ( 3, 'Bob', 27 );
 |COMMIT;
 | 
/* Query 1 */| 
SELECT * FROM users| 
WHERE age BETWEEN 10 AND 30;| 

需要指出的是事务1执行了两遍同样的查询语句。如果设了最高的隔离级别，两次会得到同样的结果集，这也正是数据库在可序列化（SERIALIZABLE）隔离级别上需要满足的。但是在较低的隔离级别上，第二次查询可能会得到不同的结果集。

在可序列化隔离级别，查询语句1在age从10到30的记录上加锁，事务2只能阻塞直至事务1提交。在可重复读级别，这个范围不会被锁定，允许记录插入，因此第二次执行语句1的结果中会包括新插入的行。


## 它与脏读,不可重复读又有什么区别?

# MySQL中的四种事务隔离级别

## 未提交读

## 已提交读

## 可重复度

## 可串行化

# 悲观锁与乐观锁

## 悲观锁

## 乐观锁

# MVCC(多版本并发控制)

## 快照读

## 当前读

## Next-Key锁
